// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from messages.djinni

package net.kullo.libkullo.api;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class Messages {
    /** Returns all messages for the given conversation */
    @NonNull
    public abstract ArrayList<Long> allForConversation(long convId);

    /**
     * Returns the message id of the latest record for the given sender address.
     * Returns -1 for addresses without a sender record.
     */
    public abstract long latestForSender(@NonNull Address address);

    /** Deletes a message */
    public abstract void remove(long msgId);

    public abstract long conversation(long msgId);

    @NonNull
    public abstract ArrayList<Delivery> deliveryState(long msgId);

    public abstract boolean isRead(long msgId);

    /** returns true iff value changed in this call */
    public abstract boolean setRead(long msgId, boolean value);

    public abstract boolean isDone(long msgId);

    /** returns true iff value changed in this call */
    public abstract boolean setDone(long msgId, boolean value);

    @NonNull
    public abstract DateTime dateSent(long msgId);

    @NonNull
    public abstract DateTime dateReceived(long msgId);

    @NonNull
    public abstract String text(long msgId);

    /**
     * Escapes special characters and wraps links into 'a' tags
     *
     * An application using this must preserve the whitespace in the HTML code,
     * i.e. treat \n and \r\n as line breaks and not strip leading or trailing
     * spaces in lines.
     * This can be archived for example by wrapping this in a html block with
     * style "white-space: pre-wrap;".
     *
     * When includeKulloAddresses is true, Kullo addresses are linked using the
     * Kullo internal scheme "kulloInternal:" followed by the unescaped address.
     * Those links must be handled by the Kullo client and must not be passed to
     * other applications since the URI scheme is not standardized and the hash
     * symbol is not compatible with a lot of applications.
     *
     * Web links are prioritized over Kullo address links and links do not overlap.
     */
    @NonNull
    public abstract String textAsHtml(long msgId, boolean includeKulloAddresses);

    @NonNull
    public abstract String footer(long msgId);

    /**
     * Full-text search for messages
     *
     * searchText: The text to search for. Does prefix matching.
     * convId: Conversation ID to filter by conversation, or -1 to search all.
     * sender: Filter by sender, if set.
     * boundary: boundary used in result highlighting; auto-generated if unset
     * limitResults: The maximum number of results to return.
     */
    @NonNull
    public abstract AsyncTask searchAsync(@NonNull String searchText, long convId, @Nullable SenderPredicate sender, int limitResults, @Nullable String boundary, @NonNull MessagesSearchListener listener);

    private static final class CppProxy extends Messages
    {
        private final long nativeRef;
        private final AtomicBoolean destroyed = new AtomicBoolean(false);

        private CppProxy(long nativeRef)
        {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
        }

        private native void nativeDestroy(long nativeRef);
        public void destroy()
        {
            boolean destroyed = this.destroyed.getAndSet(true);
            if (!destroyed) nativeDestroy(this.nativeRef);
        }
        protected void finalize() throws java.lang.Throwable
        {
            destroy();
            super.finalize();
        }

        @Override
        public ArrayList<Long> allForConversation(long convId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_allForConversation(this.nativeRef, convId);
        }
        private native ArrayList<Long> native_allForConversation(long _nativeRef, long convId);

        @Override
        public long latestForSender(Address address)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_latestForSender(this.nativeRef, address);
        }
        private native long native_latestForSender(long _nativeRef, Address address);

        @Override
        public void remove(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_remove(this.nativeRef, msgId);
        }
        private native void native_remove(long _nativeRef, long msgId);

        @Override
        public long conversation(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_conversation(this.nativeRef, msgId);
        }
        private native long native_conversation(long _nativeRef, long msgId);

        @Override
        public ArrayList<Delivery> deliveryState(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_deliveryState(this.nativeRef, msgId);
        }
        private native ArrayList<Delivery> native_deliveryState(long _nativeRef, long msgId);

        @Override
        public boolean isRead(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_isRead(this.nativeRef, msgId);
        }
        private native boolean native_isRead(long _nativeRef, long msgId);

        @Override
        public boolean setRead(long msgId, boolean value)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_setRead(this.nativeRef, msgId, value);
        }
        private native boolean native_setRead(long _nativeRef, long msgId, boolean value);

        @Override
        public boolean isDone(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_isDone(this.nativeRef, msgId);
        }
        private native boolean native_isDone(long _nativeRef, long msgId);

        @Override
        public boolean setDone(long msgId, boolean value)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_setDone(this.nativeRef, msgId, value);
        }
        private native boolean native_setDone(long _nativeRef, long msgId, boolean value);

        @Override
        public DateTime dateSent(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_dateSent(this.nativeRef, msgId);
        }
        private native DateTime native_dateSent(long _nativeRef, long msgId);

        @Override
        public DateTime dateReceived(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_dateReceived(this.nativeRef, msgId);
        }
        private native DateTime native_dateReceived(long _nativeRef, long msgId);

        @Override
        public String text(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_text(this.nativeRef, msgId);
        }
        private native String native_text(long _nativeRef, long msgId);

        @Override
        public String textAsHtml(long msgId, boolean includeKulloAddresses)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_textAsHtml(this.nativeRef, msgId, includeKulloAddresses);
        }
        private native String native_textAsHtml(long _nativeRef, long msgId, boolean includeKulloAddresses);

        @Override
        public String footer(long msgId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_footer(this.nativeRef, msgId);
        }
        private native String native_footer(long _nativeRef, long msgId);

        @Override
        public AsyncTask searchAsync(String searchText, long convId, SenderPredicate sender, int limitResults, String boundary, MessagesSearchListener listener)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_searchAsync(this.nativeRef, searchText, convId, sender, limitResults, boundary, listener);
        }
        private native AsyncTask native_searchAsync(long _nativeRef, String searchText, long convId, SenderPredicate sender, int limitResults, String boundary, MessagesSearchListener listener);
    }
}
